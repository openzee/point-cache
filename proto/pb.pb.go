// version = v2.0.2 2025/10/2 07:56

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v6.32.1
// source: pb.proto

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// 压缩算法类型
type CompressionType int32

const (
	CompressionType_CM_NONE   CompressionType = 0
	CompressionType_ZSTD      CompressionType = 1
	CompressionType_LZ4       CompressionType = 2
	CompressionType_ZLIB      CompressionType = 3
	CompressionType_CM_CUSTOM CompressionType = 99
)

// Enum value maps for CompressionType.
var (
	CompressionType_name = map[int32]string{
		0:  "CM_NONE",
		1:  "ZSTD",
		2:  "LZ4",
		3:  "ZLIB",
		99: "CM_CUSTOM",
	}
	CompressionType_value = map[string]int32{
		"CM_NONE":   0,
		"ZSTD":      1,
		"LZ4":       2,
		"ZLIB":      3,
		"CM_CUSTOM": 99,
	}
)

func (x CompressionType) Enum() *CompressionType {
	p := new(CompressionType)
	*p = x
	return p
}

func (x CompressionType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CompressionType) Descriptor() protoreflect.EnumDescriptor {
	return file_pb_proto_enumTypes[0].Descriptor()
}

func (CompressionType) Type() protoreflect.EnumType {
	return &file_pb_proto_enumTypes[0]
}

func (x CompressionType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CompressionType.Descriptor instead.
func (CompressionType) EnumDescriptor() ([]byte, []int) {
	return file_pb_proto_rawDescGZIP(), []int{0}
}

// 加密算法类型
type EncryptionType int32

const (
	EncryptionType_EC_NONE   EncryptionType = 0
	EncryptionType_AES256    EncryptionType = 1
	EncryptionType_SM4       EncryptionType = 2
	EncryptionType_ES_CUSTOM EncryptionType = 99
)

// Enum value maps for EncryptionType.
var (
	EncryptionType_name = map[int32]string{
		0:  "EC_NONE",
		1:  "AES256",
		2:  "SM4",
		99: "ES_CUSTOM",
	}
	EncryptionType_value = map[string]int32{
		"EC_NONE":   0,
		"AES256":    1,
		"SM4":       2,
		"ES_CUSTOM": 99,
	}
)

func (x EncryptionType) Enum() *EncryptionType {
	p := new(EncryptionType)
	*p = x
	return p
}

func (x EncryptionType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EncryptionType) Descriptor() protoreflect.EnumDescriptor {
	return file_pb_proto_enumTypes[1].Descriptor()
}

func (EncryptionType) Type() protoreflect.EnumType {
	return &file_pb_proto_enumTypes[1]
}

func (x EncryptionType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EncryptionType.Descriptor instead.
func (EncryptionType) EnumDescriptor() ([]byte, []int) {
	return file_pb_proto_rawDescGZIP(), []int{1}
}

type DataClass int32

const (
	DataClass_RD  DataClass = 0
	DataClass_PD  DataClass = 1
	DataClass_OMD DataClass = 2
	DataClass_MD  DataClass = 3
	DataClass_ED  DataClass = 4
	DataClass_POD DataClass = 5
	DataClass_EMD DataClass = 6
)

// Enum value maps for DataClass.
var (
	DataClass_name = map[int32]string{
		0: "RD",
		1: "PD",
		2: "OMD",
		3: "MD",
		4: "ED",
		5: "POD",
		6: "EMD",
	}
	DataClass_value = map[string]int32{
		"RD":  0,
		"PD":  1,
		"OMD": 2,
		"MD":  3,
		"ED":  4,
		"POD": 5,
		"EMD": 6,
	}
)

func (x DataClass) Enum() *DataClass {
	p := new(DataClass)
	*p = x
	return p
}

func (x DataClass) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DataClass) Descriptor() protoreflect.EnumDescriptor {
	return file_pb_proto_enumTypes[2].Descriptor()
}

func (DataClass) Type() protoreflect.EnumType {
	return &file_pb_proto_enumTypes[2]
}

func (x DataClass) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DataClass.Descriptor instead.
func (DataClass) EnumDescriptor() ([]byte, []int) {
	return file_pb_proto_rawDescGZIP(), []int{2}
}

// 数据分类分级
type DataLevel int32

const (
	DataLevel_LEVEL1 DataLevel = 0
	DataLevel_LEVEL2 DataLevel = 1
	DataLevel_LEVEL3 DataLevel = 2
)

// Enum value maps for DataLevel.
var (
	DataLevel_name = map[int32]string{
		0: "LEVEL1",
		1: "LEVEL2",
		2: "LEVEL3",
	}
	DataLevel_value = map[string]int32{
		"LEVEL1": 0,
		"LEVEL2": 1,
		"LEVEL3": 2,
	}
)

func (x DataLevel) Enum() *DataLevel {
	p := new(DataLevel)
	*p = x
	return p
}

func (x DataLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DataLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_pb_proto_enumTypes[3].Descriptor()
}

func (DataLevel) Type() protoreflect.EnumType {
	return &file_pb_proto_enumTypes[3]
}

func (x DataLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DataLevel.Descriptor instead.
func (DataLevel) EnumDescriptor() ([]byte, []int) {
	return file_pb_proto_rawDescGZIP(), []int{3}
}

// 数据类型
type DataType int32

const (
	DataType_Integer   DataType = 0 //整数
	DataType_Integer64 DataType = 1 //64位整数
	DataType_String    DataType = 2 //bytes or string
	DataType_Float     DataType = 3 //FLOAT32
	DataType_Boolean   DataType = 4 //布尔
	DataType_Double    DataType = 5 //FLOAT64
	DataType_Binary    DataType = 6 //binary,与 string是冗余的关系，友好使用
)

// Enum value maps for DataType.
var (
	DataType_name = map[int32]string{
		0: "Integer",
		1: "Integer64",
		2: "String",
		3: "Float",
		4: "Boolean",
		5: "Double",
		6: "Binary",
	}
	DataType_value = map[string]int32{
		"Integer":   0,
		"Integer64": 1,
		"String":    2,
		"Float":     3,
		"Boolean":   4,
		"Double":    5,
		"Binary":    6,
	}
)

func (x DataType) Enum() *DataType {
	p := new(DataType)
	*p = x
	return p
}

func (x DataType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DataType) Descriptor() protoreflect.EnumDescriptor {
	return file_pb_proto_enumTypes[4].Descriptor()
}

func (DataType) Type() protoreflect.EnumType {
	return &file_pb_proto_enumTypes[4]
}

func (x DataType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DataType.Descriptor instead.
func (DataType) EnumDescriptor() ([]byte, []int) {
	return file_pb_proto_rawDescGZIP(), []int{4}
}

// 信号属性
type Point struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	CreatedAt *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`    //变量更新时间或是变量请求应答时间
	VType     DataType               `protobuf:"varint,2,opt,name=v_type,json=vType,proto3,enum=DataType" json:"v_type,omitempty"` //变量的类型
	// Types that are valid to be assigned to VData:
	//
	//	*Point_IntValue
	//	*Point_Int64Value
	//	*Point_StrValue
	//	*Point_FloatValue
	//	*Point_BoolValue
	//	*Point_DoubleValue
	//	*Point_BinaryValue
	VData         isPoint_VData `protobuf_oneof:"v_data"`
	VId           uint64        `protobuf:"varint,8,opt,name=v_id,json=vId,proto3" json:"v_id,omitempty"`                   //一个点位的主键 最大值：2^64 = 18446744073709551616
	VAlias        *string       `protobuf:"bytes,9,opt,name=v_alias,json=vAlias,proto3,oneof" json:"v_alias,omitempty"`     //点位名称(额外编号)
	VDevice       *string       `protobuf:"bytes,10,opt,name=v_device,json=vDevice,proto3,oneof" json:"v_device,omitempty"` //点位关联的设备编号 BB3LT0101003009001
	VClass        *DataClass    `protobuf:"varint,11,opt,name=v_class,json=vClass,proto3,enum=DataClass,oneof" json:"v_class,omitempty"`
	VLevel        *DataLevel    `protobuf:"varint,12,opt,name=v_level,json=vLevel,proto3,enum=DataLevel,oneof" json:"v_level,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Point) Reset() {
	*x = Point{}
	mi := &file_pb_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Point) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Point) ProtoMessage() {}

func (x *Point) ProtoReflect() protoreflect.Message {
	mi := &file_pb_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Point.ProtoReflect.Descriptor instead.
func (*Point) Descriptor() ([]byte, []int) {
	return file_pb_proto_rawDescGZIP(), []int{0}
}

func (x *Point) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *Point) GetVType() DataType {
	if x != nil {
		return x.VType
	}
	return DataType_Integer
}

func (x *Point) GetVData() isPoint_VData {
	if x != nil {
		return x.VData
	}
	return nil
}

func (x *Point) GetIntValue() int32 {
	if x != nil {
		if x, ok := x.VData.(*Point_IntValue); ok {
			return x.IntValue
		}
	}
	return 0
}

func (x *Point) GetInt64Value() int64 {
	if x != nil {
		if x, ok := x.VData.(*Point_Int64Value); ok {
			return x.Int64Value
		}
	}
	return 0
}

func (x *Point) GetStrValue() string {
	if x != nil {
		if x, ok := x.VData.(*Point_StrValue); ok {
			return x.StrValue
		}
	}
	return ""
}

func (x *Point) GetFloatValue() float32 {
	if x != nil {
		if x, ok := x.VData.(*Point_FloatValue); ok {
			return x.FloatValue
		}
	}
	return 0
}

func (x *Point) GetBoolValue() bool {
	if x != nil {
		if x, ok := x.VData.(*Point_BoolValue); ok {
			return x.BoolValue
		}
	}
	return false
}

func (x *Point) GetDoubleValue() float64 {
	if x != nil {
		if x, ok := x.VData.(*Point_DoubleValue); ok {
			return x.DoubleValue
		}
	}
	return 0
}

func (x *Point) GetBinaryValue() []byte {
	if x != nil {
		if x, ok := x.VData.(*Point_BinaryValue); ok {
			return x.BinaryValue
		}
	}
	return nil
}

func (x *Point) GetVId() uint64 {
	if x != nil {
		return x.VId
	}
	return 0
}

func (x *Point) GetVAlias() string {
	if x != nil && x.VAlias != nil {
		return *x.VAlias
	}
	return ""
}

func (x *Point) GetVDevice() string {
	if x != nil && x.VDevice != nil {
		return *x.VDevice
	}
	return ""
}

func (x *Point) GetVClass() DataClass {
	if x != nil && x.VClass != nil {
		return *x.VClass
	}
	return DataClass_RD
}

func (x *Point) GetVLevel() DataLevel {
	if x != nil && x.VLevel != nil {
		return *x.VLevel
	}
	return DataLevel_LEVEL1
}

type isPoint_VData interface {
	isPoint_VData()
}

type Point_IntValue struct {
	IntValue int32 `protobuf:"varint,3,opt,name=int_value,json=intValue,proto3,oneof"` //msg.WhichOneof( 'v_data' )
}

type Point_Int64Value struct {
	Int64Value int64 `protobuf:"varint,4,opt,name=int64_value,json=int64Value,proto3,oneof"`
}

type Point_StrValue struct {
	StrValue string `protobuf:"bytes,5,opt,name=str_value,json=strValue,proto3,oneof"` //bytes or string
}

type Point_FloatValue struct {
	FloatValue float32 `protobuf:"fixed32,6,opt,name=float_value,json=floatValue,proto3,oneof"` //32bit 单精度
}

type Point_BoolValue struct {
	BoolValue bool `protobuf:"varint,7,opt,name=bool_value,json=boolValue,proto3,oneof"`
}

type Point_DoubleValue struct {
	DoubleValue float64 `protobuf:"fixed64,13,opt,name=double_value,json=doubleValue,proto3,oneof"` //64bit 双精度
}

type Point_BinaryValue struct {
	BinaryValue []byte `protobuf:"bytes,14,opt,name=binary_value,json=binaryValue,proto3,oneof"` //二进制，与string 冗余，提高友好性
}

func (*Point_IntValue) isPoint_VData() {}

func (*Point_Int64Value) isPoint_VData() {}

func (*Point_StrValue) isPoint_VData() {}

func (*Point_FloatValue) isPoint_VData() {}

func (*Point_BoolValue) isPoint_VData() {}

func (*Point_DoubleValue) isPoint_VData() {}

func (*Point_BinaryValue) isPoint_VData() {}

type Subgroup struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	Header       *Subgroup_Header       `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`                                   //用于定位子包的定位和重组
	CompressType CompressionType        `protobuf:"varint,2,opt,name=compressType,proto3,enum=CompressionType" json:"compressType,omitempty"` //先压缩，后加密
	EncryptType  EncryptionType         `protobuf:"varint,3,opt,name=encryptType,proto3,enum=EncryptionType" json:"encryptType,omitempty"`    //先压缩，后加密
	PayloadCrc32 uint32                 `protobuf:"varint,10,opt,name=payload_crc32,json=payloadCrc32,proto3" json:"payload_crc32,omitempty"` //压缩、加密后的crc32
	PushAt       *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=push_at,json=pushAt,proto3" json:"push_at,omitempty"`                     //数据包推送到其他平台的时间
	Frequency    *int32                 `protobuf:"varint,5,opt,name=frequency,proto3,oneof" json:"frequency,omitempty"`                      //该包的采集频率
	BatchSize    *uint32                `protobuf:"varint,6,opt,name=batch_size,json=batchSize,proto3,oneof" json:"batch_size,omitempty"`     //该子包中的点位个数
	// Types that are valid to be assigned to VData:
	//
	//	*Subgroup_Payload
	//	*Subgroup_PtBatch
	VData         isSubgroup_VData `protobuf_oneof:"v_data"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Subgroup) Reset() {
	*x = Subgroup{}
	mi := &file_pb_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Subgroup) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Subgroup) ProtoMessage() {}

func (x *Subgroup) ProtoReflect() protoreflect.Message {
	mi := &file_pb_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Subgroup.ProtoReflect.Descriptor instead.
func (*Subgroup) Descriptor() ([]byte, []int) {
	return file_pb_proto_rawDescGZIP(), []int{1}
}

func (x *Subgroup) GetHeader() *Subgroup_Header {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *Subgroup) GetCompressType() CompressionType {
	if x != nil {
		return x.CompressType
	}
	return CompressionType_CM_NONE
}

func (x *Subgroup) GetEncryptType() EncryptionType {
	if x != nil {
		return x.EncryptType
	}
	return EncryptionType_EC_NONE
}

func (x *Subgroup) GetPayloadCrc32() uint32 {
	if x != nil {
		return x.PayloadCrc32
	}
	return 0
}

func (x *Subgroup) GetPushAt() *timestamppb.Timestamp {
	if x != nil {
		return x.PushAt
	}
	return nil
}

func (x *Subgroup) GetFrequency() int32 {
	if x != nil && x.Frequency != nil {
		return *x.Frequency
	}
	return 0
}

func (x *Subgroup) GetBatchSize() uint32 {
	if x != nil && x.BatchSize != nil {
		return *x.BatchSize
	}
	return 0
}

func (x *Subgroup) GetVData() isSubgroup_VData {
	if x != nil {
		return x.VData
	}
	return nil
}

func (x *Subgroup) GetPayload() []byte {
	if x != nil {
		if x, ok := x.VData.(*Subgroup_Payload); ok {
			return x.Payload
		}
	}
	return nil
}

func (x *Subgroup) GetPtBatch() *SubgroupBatch {
	if x != nil {
		if x, ok := x.VData.(*Subgroup_PtBatch); ok {
			return x.PtBatch
		}
	}
	return nil
}

type isSubgroup_VData interface {
	isSubgroup_VData()
}

type Subgroup_Payload struct {
	Payload []byte `protobuf:"bytes,7,opt,name=payload,proto3,oneof"` //压缩、加密处理后的数据( batch、event)
}

type Subgroup_PtBatch struct {
	PtBatch *SubgroupBatch `protobuf:"bytes,8,opt,name=pt_batch,json=ptBatch,proto3,oneof"` //原始数据，未加密或压缩
}

func (*Subgroup_Payload) isSubgroup_VData() {}

func (*Subgroup_PtBatch) isSubgroup_VData() {}

// 离散数据
// 压缩、加密的对象
type SubgroupBatch struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PtMap         map[uint64]*Point      `protobuf:"bytes,1,rep,name=pt_map,json=ptMap,proto3" json:"pt_map,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubgroupBatch) Reset() {
	*x = SubgroupBatch{}
	mi := &file_pb_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubgroupBatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubgroupBatch) ProtoMessage() {}

func (x *SubgroupBatch) ProtoReflect() protoreflect.Message {
	mi := &file_pb_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubgroupBatch.ProtoReflect.Descriptor instead.
func (*SubgroupBatch) Descriptor() ([]byte, []int) {
	return file_pb_proto_rawDescGZIP(), []int{1, 0}
}

func (x *SubgroupBatch) GetPtMap() map[uint64]*Point {
	if x != nil {
		return x.PtMap
	}
	return nil
}

// 用于分包的跟踪和重组
type Subgroup_Header struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	GUid          int64                  `protobuf:"varint,1,opt,name=g_uid,json=gUid,proto3" json:"g_uid,omitempty"`             //组的动态ID号,分包后，子包的g_id保持一致, 全局唯一
	GCount        uint32                 `protobuf:"varint,2,opt,name=g_count,json=gCount,proto3" json:"g_count,omitempty"`       //总共切为几个包
	GIndex        uint32                 `protobuf:"varint,3,opt,name=g_index,json=gIndex,proto3" json:"g_index,omitempty"`       //该子包的序号,从0开始
	GFixid        *int64                 `protobuf:"varint,4,opt,name=g_fixid,json=gFixid,proto3,oneof" json:"g_fixid,omitempty"` //组的固定ID号，保留，组的固定ID号，暂不使用
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Subgroup_Header) Reset() {
	*x = Subgroup_Header{}
	mi := &file_pb_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Subgroup_Header) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Subgroup_Header) ProtoMessage() {}

func (x *Subgroup_Header) ProtoReflect() protoreflect.Message {
	mi := &file_pb_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Subgroup_Header.ProtoReflect.Descriptor instead.
func (*Subgroup_Header) Descriptor() ([]byte, []int) {
	return file_pb_proto_rawDescGZIP(), []int{1, 1}
}

func (x *Subgroup_Header) GetGUid() int64 {
	if x != nil {
		return x.GUid
	}
	return 0
}

func (x *Subgroup_Header) GetGCount() uint32 {
	if x != nil {
		return x.GCount
	}
	return 0
}

func (x *Subgroup_Header) GetGIndex() uint32 {
	if x != nil {
		return x.GIndex
	}
	return 0
}

func (x *Subgroup_Header) GetGFixid() int64 {
	if x != nil && x.GFixid != nil {
		return *x.GFixid
	}
	return 0
}

var File_pb_proto protoreflect.FileDescriptor

const file_pb_proto_rawDesc = "" +
	"\n" +
	"\bpb.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xb3\x04\n" +
	"\x05point\x129\n" +
	"\n" +
	"created_at\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x12 \n" +
	"\x06v_type\x18\x02 \x01(\x0e2\t.DataTypeR\x05vType\x12\x1d\n" +
	"\tint_value\x18\x03 \x01(\x05H\x00R\bintValue\x12!\n" +
	"\vint64_value\x18\x04 \x01(\x03H\x00R\n" +
	"int64Value\x12\x1d\n" +
	"\tstr_value\x18\x05 \x01(\tH\x00R\bstrValue\x12!\n" +
	"\vfloat_value\x18\x06 \x01(\x02H\x00R\n" +
	"floatValue\x12\x1f\n" +
	"\n" +
	"bool_value\x18\a \x01(\bH\x00R\tboolValue\x12#\n" +
	"\fdouble_value\x18\r \x01(\x01H\x00R\vdoubleValue\x12#\n" +
	"\fbinary_value\x18\x0e \x01(\fH\x00R\vbinaryValue\x12\x11\n" +
	"\x04v_id\x18\b \x01(\x04R\x03vId\x12\x1c\n" +
	"\av_alias\x18\t \x01(\tH\x01R\x06vAlias\x88\x01\x01\x12\x1e\n" +
	"\bv_device\x18\n" +
	" \x01(\tH\x02R\avDevice\x88\x01\x01\x12(\n" +
	"\av_class\x18\v \x01(\x0e2\n" +
	".DataClassH\x03R\x06vClass\x88\x01\x01\x12(\n" +
	"\av_level\x18\f \x01(\x0e2\n" +
	".DataLevelH\x04R\x06vLevel\x88\x01\x01B\b\n" +
	"\x06v_dataB\n" +
	"\n" +
	"\b_v_aliasB\v\n" +
	"\t_v_deviceB\n" +
	"\n" +
	"\b_v_classB\n" +
	"\n" +
	"\b_v_level\"\xa8\x05\n" +
	"\bsubgroup\x12(\n" +
	"\x06header\x18\x01 \x01(\v2\x10.subgroup.HeaderR\x06header\x124\n" +
	"\fcompressType\x18\x02 \x01(\x0e2\x10.CompressionTypeR\fcompressType\x121\n" +
	"\vencryptType\x18\x03 \x01(\x0e2\x0f.EncryptionTypeR\vencryptType\x12#\n" +
	"\rpayload_crc32\x18\n" +
	" \x01(\rR\fpayloadCrc32\x123\n" +
	"\apush_at\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\x06pushAt\x12!\n" +
	"\tfrequency\x18\x05 \x01(\x05H\x01R\tfrequency\x88\x01\x01\x12\"\n" +
	"\n" +
	"batch_size\x18\x06 \x01(\rH\x02R\tbatchSize\x88\x01\x01\x12\x1a\n" +
	"\apayload\x18\a \x01(\fH\x00R\apayload\x12,\n" +
	"\bpt_batch\x18\b \x01(\v2\x0f.subgroup.batchH\x00R\aptBatch\x1a|\n" +
	"\x05batch\x121\n" +
	"\x06pt_map\x18\x01 \x03(\v2\x1a.subgroup.batch.PtMapEntryR\x05ptMap\x1a@\n" +
	"\n" +
	"PtMapEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x04R\x03key\x12\x1c\n" +
	"\x05value\x18\x02 \x01(\v2\x06.pointR\x05value:\x028\x01\x1ay\n" +
	"\x06Header\x12\x13\n" +
	"\x05g_uid\x18\x01 \x01(\x03R\x04gUid\x12\x17\n" +
	"\ag_count\x18\x02 \x01(\rR\x06gCount\x12\x17\n" +
	"\ag_index\x18\x03 \x01(\rR\x06gIndex\x12\x1c\n" +
	"\ag_fixid\x18\x04 \x01(\x03H\x00R\x06gFixid\x88\x01\x01B\n" +
	"\n" +
	"\b_g_fixidB\b\n" +
	"\x06v_dataB\f\n" +
	"\n" +
	"_frequencyB\r\n" +
	"\v_batch_size*J\n" +
	"\x0fCompressionType\x12\v\n" +
	"\aCM_NONE\x10\x00\x12\b\n" +
	"\x04ZSTD\x10\x01\x12\a\n" +
	"\x03LZ4\x10\x02\x12\b\n" +
	"\x04ZLIB\x10\x03\x12\r\n" +
	"\tCM_CUSTOM\x10c*A\n" +
	"\x0eEncryptionType\x12\v\n" +
	"\aEC_NONE\x10\x00\x12\n" +
	"\n" +
	"\x06AES256\x10\x01\x12\a\n" +
	"\x03SM4\x10\x02\x12\r\n" +
	"\tES_CUSTOM\x10c*F\n" +
	"\tDataClass\x12\x06\n" +
	"\x02RD\x10\x00\x12\x06\n" +
	"\x02PD\x10\x01\x12\a\n" +
	"\x03OMD\x10\x02\x12\x06\n" +
	"\x02MD\x10\x03\x12\x06\n" +
	"\x02ED\x10\x04\x12\a\n" +
	"\x03POD\x10\x05\x12\a\n" +
	"\x03EMD\x10\x06*/\n" +
	"\tDataLevel\x12\n" +
	"\n" +
	"\x06LEVEL1\x10\x00\x12\n" +
	"\n" +
	"\x06LEVEL2\x10\x01\x12\n" +
	"\n" +
	"\x06LEVEL3\x10\x02*b\n" +
	"\bDataType\x12\v\n" +
	"\aInteger\x10\x00\x12\r\n" +
	"\tInteger64\x10\x01\x12\n" +
	"\n" +
	"\x06String\x10\x02\x12\t\n" +
	"\x05Float\x10\x03\x12\v\n" +
	"\aBoolean\x10\x04\x12\n" +
	"\n" +
	"\x06Double\x10\x05\x12\n" +
	"\n" +
	"\x06Binary\x10\x06B\x15Z\x13hbjyjt.com/ds/protob\x06proto3"

var (
	file_pb_proto_rawDescOnce sync.Once
	file_pb_proto_rawDescData []byte
)

func file_pb_proto_rawDescGZIP() []byte {
	file_pb_proto_rawDescOnce.Do(func() {
		file_pb_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_pb_proto_rawDesc), len(file_pb_proto_rawDesc)))
	})
	return file_pb_proto_rawDescData
}

var file_pb_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_pb_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_pb_proto_goTypes = []any{
	(CompressionType)(0),          // 0: CompressionType
	(EncryptionType)(0),           // 1: EncryptionType
	(DataClass)(0),                // 2: DataClass
	(DataLevel)(0),                // 3: DataLevel
	(DataType)(0),                 // 4: DataType
	(*Point)(nil),                 // 5: point
	(*Subgroup)(nil),              // 6: subgroup
	(*SubgroupBatch)(nil),         // 7: subgroup.batch
	(*Subgroup_Header)(nil),       // 8: subgroup.Header
	nil,                           // 9: subgroup.batch.PtMapEntry
	(*timestamppb.Timestamp)(nil), // 10: google.protobuf.Timestamp
}
var file_pb_proto_depIdxs = []int32{
	10, // 0: point.created_at:type_name -> google.protobuf.Timestamp
	4,  // 1: point.v_type:type_name -> DataType
	2,  // 2: point.v_class:type_name -> DataClass
	3,  // 3: point.v_level:type_name -> DataLevel
	8,  // 4: subgroup.header:type_name -> subgroup.Header
	0,  // 5: subgroup.compressType:type_name -> CompressionType
	1,  // 6: subgroup.encryptType:type_name -> EncryptionType
	10, // 7: subgroup.push_at:type_name -> google.protobuf.Timestamp
	7,  // 8: subgroup.pt_batch:type_name -> subgroup.batch
	9,  // 9: subgroup.batch.pt_map:type_name -> subgroup.batch.PtMapEntry
	5,  // 10: subgroup.batch.PtMapEntry.value:type_name -> point
	11, // [11:11] is the sub-list for method output_type
	11, // [11:11] is the sub-list for method input_type
	11, // [11:11] is the sub-list for extension type_name
	11, // [11:11] is the sub-list for extension extendee
	0,  // [0:11] is the sub-list for field type_name
}

func init() { file_pb_proto_init() }
func file_pb_proto_init() {
	if File_pb_proto != nil {
		return
	}
	file_pb_proto_msgTypes[0].OneofWrappers = []any{
		(*Point_IntValue)(nil),
		(*Point_Int64Value)(nil),
		(*Point_StrValue)(nil),
		(*Point_FloatValue)(nil),
		(*Point_BoolValue)(nil),
		(*Point_DoubleValue)(nil),
		(*Point_BinaryValue)(nil),
	}
	file_pb_proto_msgTypes[1].OneofWrappers = []any{
		(*Subgroup_Payload)(nil),
		(*Subgroup_PtBatch)(nil),
	}
	file_pb_proto_msgTypes[3].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_pb_proto_rawDesc), len(file_pb_proto_rawDesc)),
			NumEnums:      5,
			NumMessages:   5,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_pb_proto_goTypes,
		DependencyIndexes: file_pb_proto_depIdxs,
		EnumInfos:         file_pb_proto_enumTypes,
		MessageInfos:      file_pb_proto_msgTypes,
	}.Build()
	File_pb_proto = out.File
	file_pb_proto_goTypes = nil
	file_pb_proto_depIdxs = nil
}
